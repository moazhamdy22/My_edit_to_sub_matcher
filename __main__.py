#!/usr/bin/python
# -*- coding: UTF-8 -*-
from __future__ import print_function
from __future__ import unicode_literals
from __future__ import division
from __future__ import absolute_import
from future import standard_library

standard_library.install_aliases()

import sys
import re
from os import rename, chdir, listdir, getcwd
from builtins import str

# No longer need difflib

VIDEO_FORMAT = ('avi', 'flv', 'mkv', 'm4p', 'm4v', 'mp4', 'mpeg', 'mpg', 'webm', 'wmv')
SUBTITLE_FORMAT = ('ass', 'srt', 'ssa', 'sub', 'vtt')

# --- CONFIGURATION ---
# We can use a high threshold because our new ratio is "smarter"
MATCH_THRESHOLD = 0.9


def get_base_name(filename):
    """Helper function to get the filename without its extension."""
    return '.'.join(filename.split('.')[:-1])


def get_files(_format, files):
    """Filters and sorts files based on a tuple of extensions."""
    return sorted([f for f in files if f.split('.')[-1].lower() in _format])


def normalize_name(filename):
    """
    Strips extension and known junk patterns to get a "clean" name
    for comparison.
    """
    s = get_base_name(filename).lower()

    # Combined regex:
    # 1. ^\d+\s            : Removes "01 ", "02 ", etc. at the start
    # 2. ^(lecture|lec)-\d+- : Removes "lecture-12-" or "lec-39-" at the start
    # 3. autogenerated      : Removes "autogenerated"
    junk_patterns = r'^\d+\s|^(lecture|lec)-\d+-|autogenerated'
    s = re.sub(junk_patterns, '', s)

    # Replace all separators with a single space
    s = re.sub(r'[\.\[\]_\-\s]+', ' ', s)

    return s.strip()


def calculate_match_ratio(str1, str2):
    """
    NEW: Calculates a match ratio based on token set intersection.
    This is much better at handling "string B is a subset of string A".
    """
    tokens1 = set(str1.split())
    tokens2 = set(str2.split())

    if not tokens1 or not tokens2:
        return 0.0

    intersection_len = len(tokens1.intersection(tokens2))
    min_len = min(len(tokens1), len(tokens2))

    # How much of the smaller string is present in the larger one?
    ratio = intersection_len / min_len
    return ratio


def rename_file(sub_file, movie_file):
    """Helper function to perform the rename operation and print status."""
    movie_base_name = get_base_name(movie_file)
    sub_extension = sub_file.split('.')[-1]
    new_name = "%s.%s" % (movie_base_name, sub_extension)

    try:
        rename(sub_file, new_name)
        print("SUCCESS: '%s' -> '%s'" % (sub_file, new_name))
        return True
    except OSError as e:
        print("ERROR: Could not rename '%s': %s" % (sub_file, e))
        return False


def match_name(movies, subtitles):
    """
    Finds all possible matches, sorts them by score, and
    then executes them from best to worst.
    """

    available_movies = list(movies)
    available_subtitles = list(subtitles)

    potential_matches = []

    print("--- Calculating All Match Scores (Token Method) ---")

    # 1. Calculate all N*M match combinations
    for movie in movies:
        movie_norm_name = normalize_name(movie)
        for sub in subtitles:
            sub_norm_name = normalize_name(sub)

            # --- USE NEW RATIO FUNCTION ---
            ratio = calculate_match_ratio(movie_norm_name, sub_norm_name)

            if ratio >= MATCH_THRESHOLD:
                potential_matches.append((ratio, movie, sub))

    # 2. Sort the list by score (ratio), highest to lowest.
    potential_matches.sort(key=lambda x: x[0], reverse=True)

    print("--- Executing Best Matches First ---")

    # 3. Iterate and execute the matches
    for (ratio, movie, sub) in potential_matches:
        if movie in available_movies and sub in available_subtitles:
            print("  Match (Score: %.2f): '%s' with '%s'" % (ratio, movie, sub))
            if rename_file(sub, movie):
                available_movies.remove(movie)
                available_subtitles.remove(sub)

    # --- Handle Leftovers ---
    print("--- Checking for Leftovers ---")
    if len(available_movies) == 1 and len(available_subtitles) == 1:
        movie = available_movies[0]
        sub = available_subtitles[0]
        print("INFO: Found 1 unmatched video and 1 unmatched subtitle.")
        print("      Force-matching '%s' with '%s'" % (movie, sub))
        rename_file(sub, movie)
    else:
        print("INFO: Found %d unmatched videos and %d unmatched subtitles. No force-match." % (
        len(available_movies), len(available_subtitles)))
        if available_movies:
            print("Unmatched Videos:", available_movies)
        if available_subtitles:
            print("Unmatched Subtitles:", available_subtitles)


def main():
    try:
        target_dir = str(sys.argv[1]) if len(sys.argv) > 1 else getcwd()
        chdir(target_dir)
        print("--- Scanning Directory: %s ---" % getcwd())
    except Exception as e:
        print("FATAL: Could not access directory. %s" % e)
        return

    files_in_movie_dir = listdir(getcwd())

    if files_in_movie_dir:
        movies = get_files(VIDEO_FORMAT, files_in_movie_dir)
        subtitles = get_files(SUBTITLE_FORMAT, files_in_movie_dir)

        print("Found %d video(s) and %d subtitle(s)." % (len(movies), len(subtitles)))

        if movies and subtitles:
            match_name(movies, subtitles)
            print(">>> Done!!! <<<")
        else:
            print("Nothing to match.")
    else:
        print("There's nothing here. I'm leaving...")


if __name__ == '__main__':
    main()