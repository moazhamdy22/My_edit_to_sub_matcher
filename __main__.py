#!/usr/bin/python
# -*- coding: UTF-8 -*-
from __future__ import print_function
from __future__ import unicode_literals
from __future__ import division
from __future__ import absolute_import
from future import standard_library

standard_library.install_aliases()

import sys
import re
from os import rename, chdir, listdir, getcwd
from builtins import str

VIDEO_FORMAT = ('avi', 'flv', 'mkv', 'm4p', 'm4v', 'mp4', 'mpeg', 'mpg', 'webm', 'wmv')
SUBTITLE_FORMAT = ('ass', 'srt', 'ssa', 'sub', 'vtt')

# --- CONFIGURATION ---
MATCH_THRESHOLD = 0.9

# List of common junk tags to remove. We compile this into a single regex.
JUNK_TAGS = [
    '1080p', '720p', '480p', 'webrip', 'bluray', 'hdtv', 'x264',
    'x265', 'aac', 'dts', 'repack', 'proper', 'uncut', 'extended',
    'autogenerated'  # From our previous work
]
# This regex finds any junk tag, or the lecture-style prefixes
JUNK_REGEX = re.compile(
    r'|'.join(re.escape(tag) for tag in JUNK_TAGS) + \
    r'|^\d+\s|^(lecture|lec)-\d+-',
    flags=re.IGNORECASE
)

# This regex finds all common TV episode patterns
EPISODE_REGEX = re.compile(
    r'[sS](\d{1,2})[eE](\d{1,3})'  # S01E01
    r'|(\d+)x(\d{1,3})'  # 1x01
    r'|[eE](\d{1,3})',  # E01 (as a fallback)
    flags=re.IGNORECASE
)


def get_base_name(filename):
    """Helper function to get the filename without its extension."""
    return '.'.join(filename.split('.')[:-1])


def get_files(_format, files):
    """Filters and sorts files based on a tuple of extensions."""
    return sorted([f for f in files if f.split('.')[-1].lower() in _format])


def normalize_name(filename):
    """
    NEW: Universal normalizer for lectures AND TV shows.
    """
    s = get_base_name(filename).lower()

    # 1. Remove all known junk tags and lecture prefixes
    s = JUNK_REGEX.sub('', s)

    # 2. Standardize episode numbers
    # We want to find the episode number and make it the main part
    # of the string, prefixed with 'e'
    episode_num_str = ''
    match = EPISODE_REGEX.search(s)
    if match:
        # Find the first non-None group (e.g., '01', '01', '01')
        # S01E01 -> groups are ('01', '01', None, None, None)
        # 1x01   -> groups are (None, None, '1', '01', None)
        # E01    -> groups are (None, None, None, None, '01')
        ep_num = next(g for g in match.groups() if g is not None)
        # Standardize to "e" + number (e.g., "e01", "e150")
        episode_num_str = 'e' + ep_num.zfill(2)

        # Remove the pattern from the string to avoid double-counting
        s = EPISODE_REGEX.sub('', s)

    # 3. Clean up all separators
    s = re.sub(r'[\.\[\]_\-\s]+', ' ', s).strip()

    # 4. Return the clean name + standardized episode number
    # This ensures "naruto shippuden" + "e01" are the tokens
    return s + ' ' + episode_num_str


def calculate_match_ratio(str1, str2):
    """
    Calculates a match ratio based on token set intersection.
    """
    tokens1 = set(str1.split())
    tokens2 = set(str2.split())

    if not tokens1 or not tokens2:
        return 0.0

    intersection_len = len(tokens1.intersection(tokens2))
    min_len = min(len(tokens1), len(tokens2))

    if min_len == 0:
        return 0.0

    ratio = intersection_len / min_len
    return ratio


def rename_file(sub_file, movie_file):
    """Helper function to perform the rename operation and print status."""
    movie_base_name = get_base_name(movie_file)
    sub_extension = sub_file.split('.')[-1]
    new_name = "%s.%s" % (movie_base_name, sub_extension)

    try:
        rename(sub_file, new_name)
        print("SUCCESS: '%s' -> '%s'" % (sub_file, new_name))
        return True
    except OSError as e:
        print("ERROR: Could not rename '%s': %s" % (sub_file, e))
        return False


def match_name(movies, subtitles):
    """
    Finds all possible matches, sorts them by score, and
    then executes them from best to worst.
    """

    available_movies = list(movies)
    available_subtitles = list(subtitles)

    potential_matches = []

    print("--- Calculating All Match Scores (Universal Method) ---")

    # 1. Calculate all N*M match combinations
    for movie in movies:
        movie_norm_name = normalize_name(movie)
        for sub in subtitles:
            sub_norm_name = normalize_name(sub)

            ratio = calculate_match_ratio(movie_norm_name, sub_norm_name)

            # --- Uncomment for deep debugging ---
            # print("  > Compare: '%s' vs '%s' (Ratio: %.2f)" % (movie_norm_name, sub_norm_name, ratio))

            if ratio >= MATCH_THRESHOLD:
                potential_matches.append((ratio, movie, sub))

    # 2. Sort the list by score (ratio), highest to lowest.
    potential_matches.sort(key=lambda x: x[0], reverse=True)

    print("--- Executing Best Matches First ---")

    # 3. Iterate and execute the matches
    for (ratio, movie, sub) in potential_matches:
        if movie in available_movies and sub in available_subtitles:
            print("  Match (Score: %.2f): '%s' with '%s'" % (ratio, movie, sub))
            if rename_file(sub, movie):
                available_movies.remove(movie)
                available_subtitles.remove(sub)

    # --- Handle Leftovers ---
    print("--- Checking for Leftovers ---")
    if len(available_movies) == 1 and len(available_subtitles) == 1:
        movie = available_movies[0]
        sub = available_subtitles[0]
        print("INFO: Found 1 unmatched video and 1 unmatched subtitle.")
        print("      Force-matching '%s' with '%s'" % (movie, sub))
        rename_file(sub, movie)
    else:
        print("INFO: Found %d unmatched videos and %d unmatched subtitles. No force-match." % (
        len(available_movies), len(available_subtitles)))
        if available_movies:
            print("Unmatched Videos:", available_movies)
        if available_subtitles:
            print("Unmatched Subtitles:", available_subtitles)


def main():
    try:
        target_dir = str(sys.argv[1]) if len(sys.argv) > 1 else getcwd()
        chdir(target_dir)
        print("--- Scanning Directory: %s ---" % getcwd())
    except Exception as e:
        print("FATAL: Could not access directory. %s" % e)
        return

    files_in_movie_dir = listdir(getcwd())

    if files_in_movie_dir:
        movies = get_files(VIDEO_FORMAT, files_in_movie_dir)
        subtitles = get_files(SUBTITLE_FORMAT, files_in_movie_dir)

        print("Found %d video(s) and %d subtitle(s)." % (len(movies), len(subtitles)))

        if movies and subtitles:
            match_name(movies, subtitles)
            print(">>> Done!!! <<<")
        else:
            print("Nothing to match.")
    else:
        print("There's nothing here. I'm leaving...")


if __name__ == '__main__':
    main()